"""
###Алгоритмы сортировки и поиска

Линейный поиск:

    from random import randint

    lst = [randint(10,90) for _ in range(25)]
    print(lst)

    key = int(input('Please enter a key: '))
    for idx in range(len(lst))
        if lst[idx] == key:
            print(idx)
            break

    Цикл перебирает по 1 эл. наш список и на каждо итерациии сравнивает этот эл. с ключом,
    как только произойдет совпадение мы выведем индекс на экран и цикл завершится

    Такой алгоритм поиска хорош, когда наша последовательность сравнительно небольшая (условно до 100 эл.).
    Если последовательность большая, тисячи или миллионы...такой алгоритм будет долго работать.

Сортировка:

    Допустим у нас есть вот такой список и нужно упорядочить его по возрастанию.
    lst = [18, 59, 66, 66, 40, 53, 44, 77, 67, 10, 82, 20, 81, 47, 78, 71, 23]

    Пузырьковая сортировка:

    Мы будем попарно перебирать эл. списка. и если 1 эл будет больше второго, то мы будем менять их местами,
    потом следующую пару, пока не дойдем до конца. В конце каждого прохода, самый тяжелый эл. станет в конец
    и из следующего прохода будет исключаться. Кол-во проходов будет равно колличесву эл. списка -1.

                    1 проход:      2й:         3й:       4й:     5й:   6й:

    Конец      ->   2 2 2 2 2 2 8!| 8 8 8 8 8!| 8 8 8 8!| 8 8 8!| 8 8!| 8!
                    7 7 7 7 7 8 2 | 2 2 2 2 7!| 7 7 7 7!| 7 7 7!| 7 7!| 7!
                    8 8 8 8 8 7 7 | 7 7 7 7 2 | 2 2 2 6!| 6 6 6!| 6 6!| 6!
                    5 5 5 6 6 6 6 | 6 6 6 6 6 | 6 6 6 2 | 2 2 5!| 5 5!| 5!
                    1 1 6 5 5 5 5 | 5 5 5 5 5 | 5 5 5 5 | 5 5 2 | 2 3!| 3!
                    6 6 1 1 1 1 1 | 3 3 3 3 3 | 3 3 3 3 | 3 3 3 | 3 2 | 2!
    Начало сп. ->   3 3 3 3 3 3 3 | 1 1 1 1 1 | 1 1 1 1 | 1 1 1 | 1 1 | 1!

    Как это выглядит в коде:

    Нам понадобится функция и 2 цикла. Один цикл будет отвечать за количество проходов
    (еще раз! кол-во проходов основывается на кол-ве эл), второй цикл будет отвечать за проход по нашей
    последовательности.

        from random import randint

        lst = [randint(10,90) for _ in range(25)]
        print(lst)

        print(lst) - чтобы посмотреть список до сортировки

        def bubble_sort(array):
            for i in range (len(array) - 1):
                for j in range (len(array) - 1 - i):
                    if array[j] > array[j + 1]:
                        array[j], array[j + 1] = array[j + 1], array[j]

        bubble_sort(lst)
        print(lst)

    Тоже самое только считаем кол-во проходов:

        from random import randint

        lst = [randint(10,90) for _ in range(25)]
        print(lst)

        print(lst) - чтобы посмотреть список до сортировки

        def bubble_sort(array):
        cnt[0]
            for i in range (len(array) - 1):
                for j in range (len(array) - 1 - i):
                    if array[j] > array[j + 1]:
                        array[j], array[j + 1] = array[j + 1], array[j]
                cnt += 1
        iteration = bubble_sort(lst)
        print(iteration)
        print(lst)

    !!! Даже если для упорядочивания списка нужен 1 проход, такая программа всеравно будет выполнять
        столько проходов, сколько эл. в списке минус 1.

    Мы можем оптимизировать прогу, чтобы она не выполняла лишние приходы. Заведем переменную и будем
    перед каждым проходом подымать как флажок. Дале выполняем проход и если хотя бы 1 эл. поменялся
    местами, мы будем флажок опускать. Если флаг после очередного прохода останется поднятым, значит
    мы все отсортировали и программу можно завершать.

        from random import randint

        lst = [randint(10,90) for _ in range(25)]
        print(lst)

        print(lst) - чтобы посмотреть список до сортировки

        def bubble_sort(array):
        cnt[0]
            for i in range (len(array) - 1):
                flag = True
                for j in range (len(array) - 1 - i):
                    if array[j] > array[j + 1]:
                        array[j], array[j + 1] = array[j + 1], array[j]
                        flag - False
                cnt += 1
                if flag:
                    break
        iteration = bubble_sort(lst)
        print(iteration)
        print(lst)

        Тут будет все 1 лишний проход, он нужен для проверки.

    Вживую пузырьковую сортировку врядли встрятишь т.к. данный алгоритм неэффективен.
    Его могут использовать как составляющую более сложных алгоритмов.

Сортировка выборками:

    Суть сортировки в следующем, мы пробегаем по списку, находим наименший эл. и меняем его с первым
    эл. неотсортированой последовательности. Далее этот эл. исключается из дальнейшей обработки.

                           1й шаг: 4  5  2  3  6  1  7
                           2й шаг: 1! 5  2  3  6  4  7
                           3й шаг: 1! 2! 5  3  6  4  7
                           4й шаг: 1! 2! 3! 5  6  4  7
                           5й шаг: 1! 2! 3! 4! 6  5  7
                           6й шаг: 1! 2! 3! 4! 5! 6  7
                           7й шаг: 1! 2! 3! 4! 5! 6! 7

    Теперь как написать на питоне. Опять же нам нужна функция, которая на вход будет принимать список.
    Цикл первый будет отвечать за кол-во проходов (кол-во проходов тоже будет кол-во эл. минус 1 т.к.
    последний эл. не с чем будет сравнивать). Далее вводим переменную которая будет запоминать значение
    "i". Эта переменная будет указывать нам на первый эл. неотсортированной последовательности. Далее
    запускаем цикл, который будет выполнять поиск минимального. Поиск мы будем выполнять от "i", чтобы
    игнорировать уже отсортированные значения. Когда этот цикл завершиться, переменная "m" будет содержать
    индекс минимального эл. После того как выходим из цикла меняем местами элементы.

        from random import randint

        lst = [randint(10,90) for _ in range(25)]
        print(lst)


        def select_sort(array):
            for i in range(len(array)-1):
                m = i
                for j in range(i, len(array)):
                    if array[j] < array[m]:
                        m = j
                    array[i], array[m] = array[m], array[i]

        select_sort(lst)
        print(lst)

Сортировка простыми вставками:

    Суть данной сортировки: мы выбираем эл. из неотсортированной последовательности и пытаемся для него
    найти место в части где мы предполагаем, что последовательность отсортирована. Как джинсы в магазе
    на вешалках.

*Бывает устойчивый алгоритм сортировки и неустойчивый. Устойчивый, когда элементы с одинаковыми значениями
 не меняются местами. Неустойчивый наоборот. В большинстве случаев это не принципиально, но если к нашим
 элементам привязано эл. какого-то другого списка где значения не одинаковые, то хотелось бы использовать
 устойчивый алгоритм.

    Описываем в проге.
    Функция принимает последовательность. Первый цикл будет отвечать за то "для скольки эл-ов нам нужно
    найти место". Далее берем переменную и присвоиваем ей эл. для которого нужно найти место. С помощью
    следующего цикла ищем место для эл., сравнивая с элементами в левой части. Остановимся когда
    эл. для которого мы ищем место будет больше сравниваемого. Начинать мы будем с первого, но оставим
    на месте. Потом возьмем следущий и будем искать для него место пока не найдем и так далее.
    Если мы нашли такую позицию, где нам нужно вставить эл. То мы выполняем брейк. Если мы не нашли позицию
    то мы меняем местами эл.


        from random import randint

        lst = [randint(10,90) for _ in range(25)]
        print(lst)

        def intersection_sort(array):
            for i in range(len(array)):
                tmp = array[i]
                for j in range(i - 1, -1, -1):
                    if tmp > array[j]:
                        break

                    array[j + 1], array[j] = array[j], array[j + 1]

        insertion_sort(lst)
        print(lst)


Эксперемент с устойчивым и неустойчивым алгоритмом:

    lst1 = [13,  86,  13,  88,  56,  55,  30,  65,  64,  13,  20,  79,  72,  13,  22,  77 ]
    lst2 = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'k', 'l', 'm', 'n', 'o', 'p', 'q']


    def insertion_sort(array1, array2):
        for i in range(len(array1)):
            tmp1 = array1[i]
            tmp2 = array2[i]
            for j in range(i-1, -1, -1):
                if tmp1 >= array1[j]:
                    break

                array1[j + 1], array1[j] = array1[j], array1[j + 1]
                array2[j + 1], array2[j] = array2[j], array2[j + 1]


    insertion_sort(lst1, lst2)
    print(lst1)
    print(lst2)

    Вывод: алгоритм неустойчевый. Чтобы сделать алгоритм устойчивым, нужно к оператору сравнения добавить
           равно.

Бинарный поиск:

    Работает только с отсортированной последовательностью. Бинарный поиск основан на утверждении разделяй
    и властвуй. У нас есть ключ, значение, которое мы хотим найти в списке. Мы выбираем опорный эл.,
    который хотим найти в списке (обычно он берется из середины, не важно что слева или справа на 1 эл.
    больше. Так делают чтобы алгоритм равномерно работалю) и первое что мы делаем сравниваем опорный эл.
    с клчевым значением, если они равны, то мы нашли позицию и прекращаем поиск. Если не равны то мы
    делаем 2 проверки. 1 мы проверяем больше наш ключ чем опрны эл или меньше. Если ключ больше чем опорный
    эл., то искать его слева нет смысла и мы должны искать его справа и наоборот.

    Функция бинарного поиска выполняет поиск позиции нашего ключа и в случае если она находит такое значение.
    То она возвращает индекс этого значения. Если она не находит такое значение то она возвращает индекс
    позиции куда можно вставить такое значение.

    Описываем в коде.
    Функция принимает 4 парам - Последовательность, ключ, и границы в которых мы будем выполнять поиск.
    None - потому что мы не знаем какой размер будет у этого списка. если сортируем по всему списку
    эти два параметра можно не указывать. "middle = (left + right) // 2" - в питоне такое выражение допустимо,
    т.к. практически невозможно в питоне переполнить целочисленный тип.
    "while array[middle] != key and left <= right:" - первая проверка, совпадает ли наш ключ с эл или нет, вторая -
    позволит не оказаться в бесконечном цикле. Дальше если ключ больше опорного эл. то эл. ключ ищем справа и
    левую границу смещаем за опорный эл. и наоборот. И повторяем все заново. Когда цикл завершиться возвращаем
    кортеж True или False и индекс ел. или позиции.



    lst = [16, 17, 19, 24, 24, 25, 26, 28, 28, 30, 36, 43, 46, 49, 51, 51, 52, 59, 62, 62, 70, 73, 73, 75, 77, 80, 82, 87, 88, 88]


    def binary_search(array, key, left=0, right=None):
        if right is None:
            right = len(array)

        middle = (left + right) // 2
        while array[middle] != key and left <= right:
            if array[middle] < key:
                left = middle + 1
            else:
                right = middle - 1

            middle = (left + right) // 2

        return (True, middle) if not (left > right) else (False, middle + 1)


    print(lst)
    k = 74
    flag, idx = binary_search(lst, k)
    if flag:
        print('Element found. Index: ', idx)
    else:
        print('Element not found')
        lst.insert(idx, k)
        print(lst)

















"""
