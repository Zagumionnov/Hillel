"""
###Функции:

    Пример:

    - Что вам не нравится в этом коде?:

    print("Сколько бананов и ананасов для обезьян?")
    a = int(input())
    b = int(input())
    print("Всего", a + b, "шт."

    print("Сколько жуков и червей для ежей?")
    a = int(input())
    b = int(input())
    print("Всего", a + b, "шт."

    print("Сколько риб и молюсков для выдр?")
    a = int(input())
    b = int(input())
    print("Всего", a + b, "шт."

    -Не нравится повторяемость кода. Мы можем повторяющийся код написать отдельно и по необходимости
     обращаться к нему.



Функции бывают именованные и неименованные(анонимные). К первым можно общараться по имени.

Функция перед тем как будет использ. должна быть объявлена:

    def func_name(food1, food2):
        a = int(input())
        b = int(input())
        print("Всего", a + b, "шт.")

    print("Сколько бананов и ананасов для обезьян?")
    func_name("бананы: ", "ананасы: ")            #скобки в конце обязательны, являются ссылкой на функци

    print("Сколько жуков и червей для ежей?")
    func_name("жуки: ", "черви: ")

    print("Сколько риб и молюсков для выдр?")
    func_name("рыбы: ", "молюски: ")

Переменные объявленные в параметрах функции, мы можем исп. внутри функции.

Таким образом мы сократили программу в разы. Если возникнет потребность в изменении кода
мы будем менять его в функции.

В предыдущем примере нам подходит что результат печатается на экране, но это не всегда правильный подход,
потому что результат напечатаный на экране, нельзя больне нигде использовать.
Для того чтобы этот результат можно было дальше использовать, нужно научить программу сохранять результат
в переменной.

    res = func_name("жуки: ", "черви: ")
    print(res)

В этом случае вернется "None".

Чтобы функция что-то вернула, нужно описать это в самой функции. Используем оператор return.
Первое и основное назначение оператора - прерывание работы функции. Зачастую используется в конце
функции, но никто не запрещает использ. его внутри тела функции. Второе назначение, возрат значений.
Return возвращает всегда 1 значение.

    return a + b

    def func_name(food1, food2):
        a = int(input())
        b = int(input())
        return a + b
        #print("Всего", a + b, "шт.")  #Вот эта функция теперь выполнена не будет т.к. будет прервана
                                        оператором return

    print("Сколько бананов и ананасов для обезьян?")
    res = func_name("бананы: ", "ананасы: ")
    print("Всего", res, "шт.")

    print("Сколько жуков и червей для ежей?")
    res = func_name("жуки: ", "черви: ")
    print("Всего", res, "шт.")

    print("Сколько риб и молюсков для выдр?")
    res = func_name("рыбы: ", "молюски: ")
    print("Всего", res, "шт.")

Хорошо написанная ф-я выполняет 1 логическое действие. Поэтому вот это тоже стоит убрать:
        a = int(input())
        b = int(input())

Хорошая ф-я не должна использовать глобальные переменные. Стараться описывать ф-ю, чтобы данные попадали
через ее аргументы. Если данные в ф-ю  попадают из глобальных переменных и нам нужно будет перенести эту
ф-ю в другое место, то придется переносить вместе с переменными и не факт, что в другой проге, не окажется
таких же переменных. В итоге получим фигню.

    Пример. Отрисовка прямоугольника с пом. ф-и:
    def draw_rect(h, w):
        for _ in range(h):
            for _ in range(w):
                print('* ', end=' ')
            print()

    draw_rect(11,6)

Допустим у нас есть 2 целых числа. Функция будет возводить первое число в степерь второго.

    def my_pow(num, exp):
        return num ** exp

    print(my_pow(5, 6))

Мы можем результат не сохранять в переменную, а сразу вывести на экран, если нам это подходит.
В качесте параметров функции, можно передавать значения, переменные, вызов другой функции

    print(my_pow(my_pow(2, 3), 6 - 4))

Допустим мы хоти чтобы программа возводила число в степень. Но мы хотим чтобы при возведении числа в
степень отлично от 2, программа запрашивала степень, а если нужно в степень 2 то только число,
которое возводиться в степень. Поэтому используем аргументы по умолчанию.

    def my_pow(num, exp=2):
        return num ** exp

    print(my_pow(2, 5))
    print(my_pow(2, 5))

Если мы явно не указываем второй аргумент, то функция будет использовать аргумент по умолчанию.
Параметры по умолчанию ВСЕГДА описываются в конце списка параметров!!! Сначала обязательные, потом
идут по умолчанию. Пропускать значения можно только с конца (не указывать только для последнего и для
последних двух и т.д.).

    def func(a, b, c, d=1, e=2, f=3)
        print(a, b, c, d, e, f)

    func(10, 20, 30)

Есть возможность используя имена аргументов передавать их в любой последовательности.
    def func(a, b, c, d=1, e=2, f=3)
        print(a, b, c, d, e, f)

    func(e=67, a=54, f=6, c=9, b=0) #При этом значения обязательных аргументов передавать всеравно нужно

Существует подход при котором функция может принимать любое кол-во аргументов:
Чтобы передать функции переменное кол-во неимен. аргументов используется:

    def func_args(*args):
        print(type(args), args)

    func_args(1, 2, 3, 4)
    func_args('a', True, 4.3)
    func_args()

    Важна только *, она говорит, что все аргументы которые мы будем передавать в эту функцию
    будет упаковываться в кортеж и внутрь функции будет попадать кортеж

Чтобы описать ф-ю с перем. кол-м именов. арг:

    def func_kwargs(**kwargs)
        print(type(kwargs), kwargs)

    func_kwargs()
    func_kwargs(q=6, y=4, g=7)

    Важны **. Внутрь ф-ии мы будем получать набор аргументов как словарь.

Глобальные и локальные переменные:
В питоне существуют 4 типа переменных: -глобальные, -локальные, -статические, -встроенные
Переменные обладают временем жизни и областью видимости.

Глобальные переменные объявляется вне какого-то блока кода, доступна в пределах всего кода, время
жизни ограничена модулем.

    a = 78

Локальная объявляется в каком-то блоке кода и живет до тех пор пока мы не выйдем из блока.

    def func1():
        b = 34

Для того, чтобы перезаписать значение переменной втрутри ф-и:

    a = 78

    def func1():
        global a                                        #global - модификатор
        a = 23
        b = 34

Чтобы вернуть больше значений из функции с помощью return
самое простое вернуть кортеж:

    def func2(a, b, c):
        x1 = a + b
        x2 = b * c
        x3 = x1, x2, x3
        return x1, x2, x3

    print(func2(3, 5, 6))
    Функция вернет кортеж.
    Можем распаковать результат в одну переменную и она получит кортеж:
    y = func2(3, 5, 6)
    Можем в 3 переменные, каждая получит свое значение
    v, n, m = func2(3, 5, 6)

Анонимные функции или lambda функции. У них имени нет. Мы можем создать на них ссылку и вызывать их
по ссылке, но так крайне редко делают, потому что эти функции используют как встраиваемы ф-и, то есть
как функции, которые используются как параметр других функций.

lambda функции содержат сравнительно не сложный код, которые могут принимать параметры и быть пар-ми
других ф-й.

    def fahrenheit(temperature):
        return round(((float(9)/5)*temperature + 32), 2)

    def celsius(temperature):
        return round(((float(5)/9)*temperature - 32), 2)

    temperatures = (36.5, 37, 37.5, 38, 39)

    lst = []
    for i in temperatures:
        lst.append(fahrenheit(t))

    print(lst)

Нам не нравится первые 2 ф-ции, т.к. они используются 1 раз. Мы можем их переписать в lambda функции
и использовать их только в том месте, где в них есть необходимость, при єтом объявлять функции отдельно
нам не нужно.

Чтобы создать lambda функциюю нам нужно:

    Мы пишем lambda и объявляем список параметров x, y, z после списка параметров обязательно
    двоеточие и после него описываем выражение которое будет использовать значение аргументов
    для вычисления. Функция однострочная.

    lambda x, y, z: x + y + z

    Дорабатываем программу. Сначала избавимся от цикла.
    В питоне есть специальные функции, которые позволяют выполнить пакетную обработку коллекций.

    ф-я map - позволяет перебрать элементы кол-ции, которая была передана в качестве одного из
    аргументов этой функции и к каждому эл.(значению) этой коллекции применить функцию, которая была
    передана через другой аргумент функции map.

    map принимает 2 параметра: сслыку на функцию и коллекцию

        map(ref_func, collection)

    Функция будет перебирать каждый элемент collection и применять к ним ref_func
    map передает данные в специальны объект map, поєтому нужно преобразовать в читабельный объект
    например в список

        res = list(map(fahrenheit, temperatures))
        print(res)

    Тперь избавляемся от функции, заменяя ее на lambda:
    temperatures = (36.5, 37, 37.5, 38, 39)
    res = list(map(lambda t: round(((float(9)/5)*t + 32), 2), temperatures))
        print(res)
    res = list(map(lambda t: round(((float(5)/9)*t - 32), 2), temperatures))
        print(res)






"""


