"""
    Содержание:
    1. Кодировки
    2. Строки


Unicod - общая кодировка для символов (буквы, цифры, эмоджи...на разных языках, даже мертвых)
Unicod - представляется 1 байтовым 2 байтовым и 4 байтовым значением
nicodtable.com

print(chr(8x26bd)) - шестнадцатеричный код - увидим символ футбольного мяча
print(chr(9917)) - десятичный код - увидим символ футбольного мяча
print('\u26bd') - unicod
\u - обозначает что дальше идет 4 цифры 2-х байтного юникод символа
\U - обозначает что дальше идет 8 цифры
print(ord('⚽')) - обратная функция возвращающая юникод
print(hex(ord('⚽'))) hex преобразует из 10й сис. исч. в 16ю

print(bin(123456) - из 10й сис. исч. в 2ую
print(oct(123456) - из 10й в 8ю

16ричная система исч. самая компактная

str() - функция превращает почти любой тип данных в строку

Индексы:
    Первый индекс в строке всегда 0. Послений индекс - кол-во символов -1.
    Отрицательные идексы. Индекс последнего символа - (-1), первого - количество символов с отриц. знаком.

        0   1   2   3   4
        H   E   L   L   O
       -5  -4  -3  -2  -1

    print(s[1]) - [] - квадратные скобки - оператор индексирования

Срезы:
    s = 'Process finished with exit code 0'
    s[start: stop: range] - stop(до какого будем забирать символ, сам не войдет в выборку)
    print(s[:]) - [:] - минимально что нужно указать; заберется вся строка.
    Можно указывать только индекс начала и только индекс конца.
    Для start и stop  - можно выходить за пределы строки, вызов по конкретному индексу символа нельзя

        print(s[::-1]) - такая комбинация переворачивает строку наоборот

Циклы с строками:
    Например вывод посимвольно с помощью циклов:

        for sym in s:
            print(sym, end=' ')
        print()

    Можем сформировать с помощью индекс с помощью range а len - вернет кол-во сим. в строке,
    если в range указать 1 значение то он примет его за stop, а len возвращает кол-во симв.
    Таким образом range гарантирует что мы не вылезем за пределы строки.

        for i in range (len(s))
            print(s[i], end=' ')
        print( )

Операции с строками:
    + - склеивать
    * - получим новую строку

    Можно применять функции:
        len() - возвращает колличество символов в строке
        find(sub, start, end) - параметры start и end - необязательны

            s = "Process finished with exit code 0"
            print(s.find('oce', len('oce')+2)

        rfind(sub, start, end) - поиск начинается с права

        replace(old, new, count)

            s = "Process finished with exit code 0"
            print(s.replace('oce', 'OCE'))

        count('str') - считает кол-во символов в строке

            print(s.count('s'))

        lower() - перевод на нижний регистр
        upper() - перевод на верхний регистр

        strip(" ") - позволяет очистить строку с лева и с права от ненужных символов



"""


